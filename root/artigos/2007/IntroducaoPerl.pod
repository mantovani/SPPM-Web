=pod

r6 - 02 Mar 2007 - AlceuJunior

=head1 Uma introdução ao Perl

I<>

IntroduE<ccedil>E<atilde>o E<agrave> linguagem de
programaE<ccedil>E<atilde>o Perl.

Neste artigo o leitor terE<aacute> uma introduE<ccedil>E<atilde>o
E<agrave> linguagem de programaE<ccedil>E<atilde>o Perl. Assume-se que
o leitor jE<aacute> tenha algum conhecimento bE<aacute>sico sobre
programaE<ccedil>E<atilde>o (como uso de variE<aacute>veis, fluxo de
execuE<ccedil>E<atilde>o de um programa e um pouco de lE<oacute>gica de
programaE<ccedil>E<atilde>o) e de como utilizar o I<shell> de um
sistema operacional UNIX, como o Linux. Conhecer um pouco de I<shell
script> tambE<eacute>m ajudarE<aacute> bastante.

Ao invE<eacute>s de comeE<ccedil>ar a explicar os detalhes da linguagem
antes de fazer qualquer coisa mais E<uacute>til que uma calculadora, o
leitor vai desenvolver durante o artigo um programa simples enquanto o
pode aprender gradativamente o bE<aacute>sico da linguagem.

O programa farE<aacute> algo simples: procurarE<aacute> por arquivos
MP3 num local indicado (ou prE<eacute>-definido como o
diretE<oacute>rio atual de execuE<ccedil>E<atilde>o do programa, caso
nenhum seja especificado) e listarE<aacute> todas as
informaE<ccedil>E<otilde>es gravadas no cabeE<ccedil>alho dos mesmos
(assumindo, por exemplo, que os arquivos jE<aacute> foram criados com
essas informaE<ccedil>E<otilde>es obtidas, por exemplo, de um servidor
CDDB).

=over

=item * CaracterE<iacute>sticas

=item * Um breve histE<oacute>rico

=item * Providenciando o ambiente de programaE<ccedil>E<atilde>o
mE<iacute>nimo

=item * Os requisitos do programa

=item * Molhando os pE<eacute>s

=item * ConclusE<atilde>o

=item * Bibliografia

=item * Obras impressas

=item * Notas

=back

=head2 CaracterE<iacute>sticas

Se vocE<ecirc> jE<aacute> programou em I<shell script>, logo vai ter a
agradE<aacute>vel surpresa de descobrir que com pouco tempo de
aprendizado em Perl vocE<ecirc> jE<aacute> poderE<aacute> substituir
alguns de seus programas com muito mais elegE<acirc>ncia, facilidade e,
na maioria dos casos, maior performance. Na
distribuiE<ccedil>E<atilde>o padrE<atilde>o do Perl atE<eacute> existe
um programa(1), por exemplo, que converte automaticamente programas
feitos em Sed para cE<oacute>digo equivalente em Perl.

Perl E<eacute> muito utilizada tambE<eacute>m como I<glue language>
(linguagem de cola), exatamente como um I<shell script>, dada a
facilidade para executar outros programas e capturar a saE<iacute>da
gerada pelos mesmos, isso sem considerar a possibilidade
razoE<aacute>vel de encontrar substitutos para esses programas em
cE<oacute>digo Perl pronto para usar no repositE<oacute>rio central de
mE<oacute>dulos conhecido como CPAN.

VocE<ecirc> encontra essa linguagem instalada por padrE<atilde>o em
qualquer sistema clone do UNIX de respeito, incluindo o Linux. Mas Perl
nE<atilde>o se limita a apenas esses sistemas, sendo ela multiplaforma:
isso gera possibilidades muito interessantes, como criar programas que
possam rodar em sistemas operacionais diferentes sem reescrever nenhum
cE<oacute>digo. Hoje ela estE<aacute> disponE<iacute>vel para sistemas
como Microsoft Windows (vE<aacute>rias versE<otilde>es), MAC OS, BeOS e
muitos outros.

Um dos lemas principais do Perl E<eacute> E<147>existe mais de uma
maneira de fazerE<148>(2): a expressividade da linguagem E<eacute>
tE<atilde>o grande que algumas pessoas conseguem escrever poemas
utilizando cE<oacute>digo funcional em Perl (entenda por cE<oacute>digo
funcional algo que E<eacute> executado e gera alguma saE<iacute>da, sem
erros).

Perl foi desenvolvida inicialmente utilizando um paradigma procedural
mas E<eacute> plenamente possE<iacute>vel utilizar
orientaE<ccedil>E<atilde>o E<agrave> objetos tambE<eacute>m (utilizando
todos os recursos desse paradigma). Se o programador preferir, ainda
E<eacute> possE<iacute>vel ter programas procedurais instanciando
objetos sem o menor problema.

Outros recursos disponE<iacute>veis como gerar
documentaE<ccedil>E<atilde>o I<online> diretamente no cE<oacute>digo do
programa (B<perldoc>) em diversos formatos, suporte a
expressE<otilde>es regulares (tE<atilde>o completo que Perl E<eacute>
uma referE<ecirc>ncia sobre esse assunto) e a capacidade de integrar
cE<oacute>digo Perl com outras linguagens como C, C++ e Java.

Perl oferece amplo suporte ao desenvolvedor, incluindo um poderoso
I<debugger> em linha de comando e mE<oacute>dulos para medir
performance (B<Benchmark> e B<Devel::DProf>).

=head2 Um breve histE<oacute>rico

Perl foi criada em 1987 pelo entE<atilde>o programador de sistemas
Larry Wall. Nessa E<eacute>poca ele recebeu como tarefa gerar
relatE<oacute>rios de um sistema de controle em mE<aacute>quinas UNIX e
sua primeira tentativa foi utilizar B<awk> para fazer essa tarefa.
Quando ele concluiu que B<awk> nE<atilde>o era tE<atilde>o
flexE<iacute>vel quanto ele gostaria, ele arregaE<ccedil>ou as mangas e
criou essa fantE<aacute>stica linguagem, liberando-a pouco tempo depois
como software livre.

PERL E<eacute> um acrE<ocirc>nimo e significa I<Pratical Extraction
Report Language> (Linguagem PrE<aacute>tica de ExtraE<ccedil>E<atilde>o
e RelatE<oacute>rios) e era utilizada exatamente para isso: extrair
informaE<ccedil>E<otilde>es e gerar relatE<oacute>rios. ApE<oacute>s
sua liberaE<ccedil>E<atilde>o e depois de algumas
contribuiE<ccedil>E<otilde>es ela passou a ser bem mais do que isso.
Hoje, Perl E<eacute> uma linguagem completa e E<eacute> utilizada nos
mais diversos campos como suporte a gerenciamento de sistemas,
processamento de grE<aacute>ficos, acesso E<agrave> banco de dados,
aplicaE<ccedil>E<otilde>es web e grE<aacute>ficas e engenharia
genE<eacute>tica.

A linguagem passou a ficar mais conhecida ainda com o advento de
aplicaE<ccedil>E<otilde>es dinE<acirc>micas na web, onde ganhou o
apelido de E<147>cola da InternetE<148>, sendo muito utilizada para
criar CGI's(3).

=head2 Providenciando o ambiente de programaE<ccedil>E<atilde>o
mE<iacute>nimo

Se vocE<ecirc> utiliza o Linux como sistema operacional E<eacute> muito
provE<aacute>vel que Perl jE<aacute> esteja instalado. Para confirmar
isso, abra um terminal e execute

 $ perl -v

No I<website> oficial do Perl em http://www.perl.org vocE<ecirc>
irE<aacute> encontrar, alE<eacute>m do cE<oacute>digo fonte para
compilaE<ccedil>E<atilde>o, links para diversas opE<ccedil>E<otilde>es
de Perl prE<eacute>-compilado para diversos sistemas operacionais (para
sistemas Microsoft Windows, por exemplo, procure em
http://www.activestate.com). Para sistemas Linux, no entanto, o mais
simples E<eacute> utilizar o sistema de pacotes da
distribuiE<ccedil>E<atilde>o para cuidar dessa
instalaE<ccedil>E<atilde>o. Para o Debian GNU Linux, por exemplo,
E<eacute> muito simples resolver esse problema. Basta executar na linha
de comando um

 $ apt-get install perl

e aguardar o sistema de pacotes instalar e configurar tudo para
vocE<ecirc>.

Se vocE<ecirc> repetir o comando para verificar a versE<atilde>o
novamente, verE<aacute> algo parecido com a saE<iacute>da abaixo:

 C:\> perl -v
 
 This is perl, v5.8.8 built for MSWin32-x86-multi-thread
 (with 33 registered patches, see perl -V for more detail)
 
 Copyright 1987-2006, Larry Wall
 
 Binary build 819 [267479] provided by ActiveState http://www.ActiveState.com
 Built Aug 29 2006 12:42:41
 
 Perl may be copied only under the terms of either the Artistic License or the
 GNU General Public License, which may be found in the Perl 5 source kit.
 
 Complete documentation for Perl, including FAQ lists, should be found on
 this system using "man perl" or "perldoc perl".  If you have access to the
 Internet, point your browser at http://www.perl.org/, the Perl Home Page.

AlE<eacute>m do Perl instalado, vocE<ecirc> irE<aacute> precisar de um
editor de textos simples da sua preferE<ecirc>ncia. Se vocE<ecirc>
conhece e utiliza o Vim, recomendo fortemente que instale o I<plugin
perl-support.vim> do mesmo.

=head2 Os requisitos do programa

Para simplificar o aprendizado o programa usarE<aacute> um paradigma
procedural. O fluxo de processamento que desejamos estE<aacute>
ilustrado no diagrama abaixo:

=over

=item * Fluxo de execuE<ccedil>E<atilde>o do programa:

fluxo.png

=back

=head2 Molhando os pE<eacute>s

Nosso primeiro passo serE<aacute> entender que Perl nE<atilde>o
E<eacute> uma linguagem compilada, no sentido do programador ter que
gerar cE<oacute>digo de mE<aacute>quina antes de executar o programa,
mas E<eacute> interpretada pelo Perl e depois executada (bem, na
verdade nE<atilde>o E<eacute> exatamente assim, mas isso E<eacute> tudo
que vocE<ecirc> precisa saber no momento).

Tendo isso em mente, temos duas formas principais de executar um
programa em Perl no Linux:

1.executando o interpretador Perl na linha de comando, passando como
parE<acirc>metro um arquivo contendo cE<oacute>digo para ser executado,
desta forma:

 $ perl nome-do-arquivo

2.dar permissE<atilde>o de execuE<ccedil>E<atilde>o ao arquivo e
adicionar o cE<oacute>digo abaixo no inE<iacute>cio do mesmo:

 #!/usr/bin/perl

Perceba que a segunda forma nE<atilde>o E<eacute> cE<oacute>digo Perl.
Chamada comumente de I<shebang_(4) essa linha serve para que o _shell>
procure o interpretador a ser utilizado no caminho completo passado
apE<oacute>s o sinal de exclamaE<ccedil>E<atilde>o. Essa forma
E<eacute> simples e evita repetir digitaE<ccedil>E<otilde>es na linha
de comando. Se o Perl estiver instalado em um diretE<oacute>rio
diferente, vocE<ecirc> terE<aacute> que modificar essa linha com o
caminho correto.

Edite um arquivo com o nome B<descritor.pl>. A extensE<atilde>o no
Linux E<eacute> desnecessE<aacute>ria, mas o leitor terE<aacute> que
usE<aacute>-la, por exemplo, caso deseje rodar esse programa no MS
Windows. Inclua entE<atilde>o as seguintes linhas no arquivo:

 #!/usr/bin/perl
 use warnings;
 use strict;

A primeira linha vocE<ecirc> jE<aacute> sabe do que se trata,
entE<atilde>o vamos dar uma olhada nas duas seguintes.

A palavra reservada B<use> E<eacute> uma instruE<ccedil>E<atilde>o que
carrega mE<oacute>dulos no seu programa. ME<oacute>dulos sE<atilde>o as
unidades bE<aacute>sicas de reaproveitamento bE<aacute>sico de
cE<oacute>digo Perl: pense neles como bibliotecas. Estes
mE<oacute>dulos sE<atilde>o procurados em diretE<oacute>rios
prE<eacute>-definidos durante a compilaE<ccedil>E<atilde>o do
cE<oacute>digo fonte do Perl e estes diretE<oacute>rios sE<atilde>o
armazenados em forma de lista numa variE<aacute>vel de ambiente chamada
B<@INC>. Se vocE<ecirc> estiver particularmente curioso, pode executar
o comando abaixo num terminal:

 perl -e 'map { print $_, "\n" } @INC'

SerE<aacute> entE<atilde>o impressa uma lista dos diretE<oacute>rios
sendo usados como repositE<oacute>rios.

Voltando a instruE<ccedil>E<atilde>o use, ela espera como argumento o
nome do mE<oacute>dulo a ser carregado. Os mE<oacute>dulos I<warnings>
e I<strict> sE<atilde>o E<147>pragmasE<148>, mE<oacute>dulos que
alteram o comportamento normal do interpretador Perl. Esses dois
mE<oacute>dulos ajudam muito durante o desenvolvimento do programa, lhe
avisando de possE<iacute>veis erros (I<warnings>) que nE<atilde>o
farE<atilde>o o programa abortar mas podem causar erros de
lE<oacute>gica ou entE<atilde>o abortar o programa quando se tenta
utilizar variE<aacute>veis nE<atilde>o declaradas previamente (entre
outras coisas). Por padrE<atilde>o, nE<atilde>o se declarava
variE<aacute>veis em Perl: uma variE<aacute>vel passa a existir a
partir do momento que vocE<ecirc> atribui um valor a ela. Isso pode
causar algumas confusE<otilde>es, como declarar uma variE<aacute>vel e
mais tarde digitar errado o nome de uma variE<aacute>vel e tentar
utilizE<aacute>-la: se o programa usar I<warnings> o programador ainda
receberE<aacute> um aviso de que estE<aacute> usando uma
variE<aacute>vel indefinida; caso contrE<aacute>rio, nE<atilde>o
perceberE<aacute> o erro! A pragma I<strict> jE<aacute> aborta o
programa nesses casos, forE<ccedil>ando o programador a arrumar o erro.

Voltando ao exemplo, vamos adicionar mais uma linha para exemplificar
isso:

 print ÂWelcome to MP3 descriptor - $version\nÂ;

O programa agora jE<aacute> pode executar alguma coisa, imprimindo uma
mensagem de boas vindas. O comando B<print> cuida disso, imprimindo os
parE<acirc>metros passados para ele. Esse comando aceita muitas
opE<ccedil>E<otilde>es, como selecionar o destino da impressE<atilde>o
que pode ser a tela, um arquivo ou um soquete de rede. Devido a sua
heranE<ccedil>a UNIX, Perl usa o conceito de saE<iacute>da
padrE<atilde>o (B<STDOUT>), saE<iacute>da de erro padrE<atilde>o
(B<STDERR>) e entrada padrE<atilde>o (B<STDIN>). Como o padrE<atilde>o
E<eacute> imprimir coisas na tela (B<STDOUT>), B<print> permite que
vocE<ecirc> omita a saE<iacute>da desejada para a impressE<atilde>o.

Se vocE<ecirc> jE<aacute> programou em I<shell script> (ou outras
linguagens com recurso semelhante, como Javascript) deve ter notado o
uso das aspas duplas nessa linha de cE<oacute>digo. Aspas duplas em
Perl significam que o interpretador deve retornar o texto que
estE<aacute> entre as aspas, interpolando quaisquer variE<aacute>veis
que estejam ali, concatenando seus valores com o restante do texto. No
caso, as variE<aacute>veis ali presentes sE<atilde>o B<$version> e o
caracter de quebra de linha B<E<147>\nE<148>>. Ignore por enquanto o
caracter engraE<ccedil>ado no nome da variE<aacute>vel, jE<aacute> vou
falar sobre ele.

Se vocE<ecirc> ainda nE<atilde>o deu permissE<atilde>o de
execuE<ccedil>E<atilde>o ao descritor.pl, faE<ccedil>a isso agora:

 jackal@valhalla:~$ chmod 700 descritor.pl

Se vocE<ecirc> executar o programa do jeito que estE<aacute>,
receberE<aacute> um erro:

 jackal@valhalla:~$ ./descritor.pl
 Global symbol "$version" requires explicit package name at ./descritor.pl line 5.
 Execution of ./descritor.pl aborted due to compilation errors.

O erro aconteceu porque B<symbol> se refere a uma variE<aacute>vel
nE<atilde>o declarada chamada B<$version>. Esse erro foi gerado pela
pragma I<strict> e para eliminar o problema, basta modificar um pouco o
programa. Para evitar repetir linhas, apenas a parte modificada
serE<aacute> mostrada, em destaque:

 use strict;
 # versÃ£o do sistema
 my $version;
 print ÂWelcome to MP3 descriptor Â version $version\nÂ;

Na primeira nova linha o leitor vai se deparar com um tE<iacute>pico
comentE<aacute>rio: o caractere de sustenido (#) diz ao interpretador
Perl para ignorar tudo o que vier apE<oacute>s esse caracter
atE<eacute> a prE<oacute>xima quebra de linha. Perl nE<atilde>o possui
caracteres de comentE<aacute>rio multilinhas, como C e C++.

Executar o programa novamente faz a pragma B<warnings> entrar em
aE<ccedil>E<atilde>o:

 jackal@valhalla:~$ ./descritor.pl
 Use of uninitialized value in concatenation (.) or string at ./descritor.pl line 7.
 Welcome to MP3 descriptor -
 jackal@valhalla:~$

Esse erro aconteceu porque a variE<aacute>vel B<$version>, apesar de
declarada corretamente, nE<atilde>o tem valor nenhum e a pragma tratou
de avisar sobre isso quando o interpretador tentou fazer a
concatenaE<ccedil>E<atilde>o do texto com o valor de B<$version>. O
aviso serE<aacute> evitado se for atribuE<iacute>do um valor inicial
E<agrave> variE<aacute>vel (o que E<eacute> uma boa prE<aacute>tica de
programaE<ccedil>E<atilde>o, de qualquer forma). Para evitar repetir
linhas, apenas a parte modificada serE<aacute> mostrada, em destaque:

 use strict;
 
 # versÃ£o do sistema
 my $version = 1;
 
 print "Welcome to MP3 descriptor - $version\n";

Executando novamente, teremos:

 jackal@valhalla:~$ ./descritor.pl
 Welcome to MP3 descriptor - 1
 jackal@valhalla:~$

A palavra reservada B<my> diz ao Perl que vocE<ecirc> estE<aacute>
definindo uma variE<aacute>vel dentro do escopo atual, que para o
descritor.pl significa o arquivo todo. Seguindo em frente vocE<ecirc>
vai reparar o caracter engraE<ccedil>ado E<147>$E<148> seguido de um
conjunto de caracteres que, espera-se, definam um nome
inteligE<iacute>vel para a variE<aacute>vel. O caracter de
cifrE<atilde>o identifica o tipo de variE<aacute>vel mais
bE<aacute>sico de Perl chamada I<scalar>. Uma variE<aacute>vel
I<scalar> (escalar, em portuguE<ecirc>s) pode armazenar caracteres ou
nE<uacute>meros e o interpretador do Perl vai utilizar esses valores da
forma mais conveniente possE<iacute>vel, seja para gerar saE<iacute>da,
realizar uma operaE<ccedil>E<atilde>o matemE<aacute>tica ou concatenar
nE<uacute>meros e caracteres sem necessidade alguma de
conversE<atilde>o de tipos. Utilizando entE<atilde>o o caractere de
igual (=) atribuE<iacute>mos E<agrave> B<$version> o valor 1. Se fosse
desejE<aacute>vel que B<$version> tivesse um valor alfanumE<eacute>rico
como E<147>bacana nE<uacute>mero 1E<148>, basta utilizar aspas simples
(que nE<atilde>o tentam interpolar variE<aacute>veis) ou aspas duplas.

Escalares podem armazenar outros tipos de literais numE<eacute>ricas.
Veja uns exemplos:

 # ponto flutuante
 my $exemplo1 = 234.56;
 # notaÃ§Ã£o cientÃ­fica
 my $exemplo2 = 32.04e12;
 # um inteiro bem grande, sublinhado para facilitar a leitura
 my $exemplo3 = 36_152_695;
 # declaraÃ§Ã£o de um octal (basta usar zero no inÃ­cio)
 my $exemplo4 = 0377;
 # declaraÃ§Ã£o de um hexadecimal (como o octal, mas usando Â0xÂ)
 my $exemplo5 = 0xffff;
 # declaraÃ§Ã£o de um binÃ¡rio (como octal, mas usando Â0bÂ)
 my $exemplo6 = 0b1100_0000;

AlE<eacute>m de caracteres e nE<uacute>meros, uma variE<aacute>vel
escalar pode armazenas referE<ecirc>ncias. ReferE<ecirc>ncias E<eacute>
um assunto um pouco complexo (e extenso) para ser abordado neste
artigo, mas basta vocE<ecirc> saber no momento que referE<ecirc>ncias
sE<atilde>o utilizadas, em geral, para criar estruturas de dados
multidimensionais em Perl.

O leitor atento jE<aacute> deve ter percebido que cada
instruE<ccedil>E<atilde>o escrita termina em ponto e vE<iacute>rgula
(E<147>;E<148>): Perl ignora espaE<ccedil>os,
tabulaE<ccedil>E<otilde>es e quebras de linha mas o programador
precisar terminar instruE<ccedil>E<otilde>es com E<147>;E<148>. Existem
algumas excessE<otilde>es, mas no geral vocE<ecirc> pode adotar isso
sem maiores preocupaE<ccedil>E<otilde>es.

Agora o programa descritor.pl jE<aacute> E<eacute> executado sem erros,
gera alguma saE<iacute>da e ainda utiliza algumas boas prE<aacute>ticas
de programaE<ccedil>E<atilde>o em Perl. Mas ainda nE<atilde>o atende
sua proposta: obter informaE<ccedil>E<otilde>es de arquivos MP3. Os
requisitos do programa dizem que ele deve procurar por arquivos MP3 num
diretE<oacute>rio dado como parE<acirc>metro ou ainda tentar no
diretE<oacute>rio corrente daonde o programa foi executado. O primeiro
passo E<eacute> modificar o programa novamente para receber esse
parE<acirc>metro, incluindo mais cE<oacute>digo. Para evitar repetir
linhas, apenas a parte modificada serE<aacute> mostrada, em destaque:

 print "Welcome to MP3 descriptor Â version $version\n";
 
 my $location = $ARGV[0];
 print "Will try to find program at $location\n" if ( defined($location) );

As duas E<uacute>ltimas linhas do programa incluem a
declaraE<ccedil>E<atilde>o de uma nova variE<aacute>vel e da
impressE<atilde>o de uma mensagem de acordo com um teste condicional.
Na penE<uacute>ltima linha, observe que B<$location> recebe o valor de
um outro tipo de variE<aacute>vel em Perl: um I<array>. Um I<array>
nada mais E<eacute> do que uma lista de valores, que vocE<ecirc> acessa
indicando um indE<iacute>ce numE<eacute>rico para recuperar o valor
desejado.

VocE<ecirc> tambE<eacute>m utiliza caracteres engraE<ccedil>ados para
manipular listas, como mostrado no cE<oacute>digo acima. Para declarar
ou se referir a uma lista como um todo, vocE<ecirc> faz desta forma:

 my @list_of_mp3;

Para atribuir valores, vocE<ecirc> deve passar uma lista de valores
dentro de parE<ecirc>nteses, sendo que cada valor deve ser separado por
vE<iacute>rgulas. Se estiver usando I<strings>, vocE<ecirc> tem que se
lembrar de utilizar aspas (simples ou dupla):

 my @list_of_mp3 = ('rock.mp3','blues.mp3','samba.mp3');

Agora se vocE<ecirc> estiver se sentido particularmente
preguiE<ccedil>oso para digitar todas essas aspas e vE<iacute>rgulas, a
funE<ccedil>E<atilde>o B<qw> pode lhe ajudar com isso:

 my @list_of_mp3 = qw(rock.mp3 blues.mp3 samba.mp3);

Executar B<perldoc -f qw> vai lhe dar mais detalhes sobre essa
funE<ccedil>E<atilde>o;

Repare no entanto que em lugar nenhum foi declarada o I<array>
B<@ARGV>: essa E<eacute> uma variE<aacute>vel especial do Perl, tal
qual B<@INC>, que por sinal tambE<eacute>m E<eacute> uma lista.
B<@ARGV> mantE<ecirc>m registrado todas os parE<acirc>metros recebidos
durante a chamada para execuE<ccedil>E<atilde>o de um programa ou de
uma funE<ccedil>E<atilde>o. Normalmente vocE<ecirc> nE<atilde>o precisa
se preocupar muito com isso porque Perl tem o cuidado de passar para
sempre o que vocE<ecirc> quer, desde que vocE<ecirc> nE<atilde>o tenha
intenE<ccedil>E<atilde>o de acessar valores em B<@ARGV> num escopo
diferente do atual que estE<aacute> trabalhando. No caso do programa,
basta pegar a primeira opE<ccedil>E<atilde>o fornecida na linha de
comando, se houver alguma.

Existem muitos outros usos e truques com I<arrays>, como o uso de
fatias. Mas isso fica para outro artigo.

A E<uacute>ltima linha faz um teste para verificar se o
parE<acirc>metro foi informado ou nE<atilde>o usando as
instruE<ccedil>E<otilde>es B<if> e B<defined>. A
instruE<ccedil>E<atilde>o B<if> tem vE<aacute>rias formas de
execuE<ccedil>E<atilde>o alE<eacute>m dessas que utilizamos. Para
aprender sobre todas essas opE<ccedil>E<otilde>es, utilize a
documentaE<ccedil>E<atilde>o I<online> do Perl para fazer isso:

 jackal@valhalla:~$ perldoc perlintro
 jackal@valhalla:~$ perldoc perlop

Em ambos os casos, procure as seE<ccedil>E<otilde>es de operadores
condicionais. Quanto E<agrave> instruE<ccedil>E<atilde>o B<defined>,
ela testa se a variE<aacute>vel escalar (I<scalar>) passada como
parE<acirc>metro possui um valor definido ou nE<atilde>o. Ela
nE<atilde>o funciona com listas (I<arrays>).

Agora o programa deve tratar de procurar arquivos no diretE<oacute>rio
corrente caso nE<atilde>o receba parE<acirc>metros na sua
execuE<ccedil>E<atilde>o. Para evitar repetir linhas, apenas a parte
modificada serE<aacute> mostrada, em destaque:

 use strict;
 use Cwd;
 
 # versÃ£o do sistema
 my $version = 1;
 print "Welcome to MP3 descriptor - $version\n";
 
 my $location;
 
 if (@ARGV) {
 
     $location = $ARGV[0];
     print "Will try to find files at $location\n";
 
 } else {
 
     $location = getcwd;
     print "Will try to find files at current directory ($location)\n";
 
 }

Observe como foi testada B<@ARGV>: isso, no linguajar de Perl,
E<eacute> chamado de uso em contexto escalar: quando vocE<ecirc> usa
uma array dessa forma ele nE<atilde>o retorna uma lista, mas sim o
nE<uacute>mero de elementos que ele armazena. Se o programa recebeu
alguma coisa (com sorte a localizaE<ccedil>E<atilde>o do
diretE<oacute>rio aonde estE<atilde>o os arquivos mp3) entE<atilde>o
B<@ARGV> retornarE<aacute> o valor 1 (ou mais) o que torna a
declaraE<ccedil>E<atilde>o verdadeira e possibilita a
execuE<ccedil>E<atilde>o do cE<oacute>digo seguinte.

Adicionamos tambE<eacute>m mais um mE<oacute>dulo ao programa: o B<Cwd>
fornece uma funE<ccedil>E<atilde>o chamada B<getcwd> que quando
executada retorna o diretE<oacute>rio atual daonde o programa foi
executado. O uso dessa funE<ccedil>E<atilde>o permite que o
descritor.pl tente encontrar arquivos mp3 no diretE<oacute>rio atual de
execuE<ccedil>E<atilde>o.

Observe a diferenE<ccedil>a ao executar o programa de formas
diferentes:

 jackal@valhalla:~$ ./descritor.pl /home/jackal/musicas
 Welcome to MP3 descriptor - version 1
 Will try to find files at /home/jackal/musicas

E agora sem parE<acirc>metro algum:

 jackal@valhalla:~$ ./descritor.pl
 Welcome to MP3 descriptor - version 1
 Will try to find files at current directory (/home/jackal)

Agora E<eacute> hora de procurar esses arquivos mp3. Para evitar
repetiE<ccedil>E<atilde>o de cE<oacute>digo no programa o ideal seria
criar uma funE<ccedil>E<atilde>o para fazer isso.
FunE<ccedil>E<otilde>es em Perl sE<atilde>o chamadas de subrotinas e a
declaraE<ccedil>E<atilde>o dela ficaria da seguinte forma:

 # Essa funÃ§Ã£o procura por arquivos mp3 no diretÃ³rio
 # passado como argumento e retorna uma lista dos
 # arquivos encontrados
 sub find_mp3 {
 
     my $location = shift;
         $location .= '/';
 
     warn "No location passed as argument\n" unless ( defined($location) );
 
     my @list = <$location*.mp3>;
 
     warn "No MP3 files found\n" unless (@list);
 
     return @list;
 
 }

Uma declaraE<ccedil>E<atilde>o de subrotina comeE<ccedil>a sempre com a
palavra reservada sub, seguida de seu nome. A
declaraE<ccedil>E<atilde>o do cE<oacute>digo deve ser feita entre
chaves (E<147>{E<147> e E<147>}E<148>). Subrotinas podem ser declaradas
em qualquer lugar do programa, mas normalmente sE<atilde>o feitas no
inE<iacute>cio ou no fim do programa. Neste programa-exemplo,
B<find_mp3> serE<aacute> declarada no final do arquivo descritor.pl.

Dentro da chave, perceba que declaramos outra variE<aacute>vel chamada
B<$location>: ela nE<atilde>o tem nenhuma relaE<ccedil>E<atilde>o com a
outra variE<aacute>vel de mesmo nome declarada no corpo principal do
programa: a funE<ccedil>E<atilde>o de B<my> E<eacute> justamente evitar
variE<aacute>veis globais. B<$location> terE<aacute> como valor
atribuE<iacute>do o valor retornado pela funE<ccedil>E<atilde>o
B<shift>, que por sua vez retorna o primeiro valor de um I<array>, da
esquerda para direita, diminuindo o tamanho do I<array> durante o
processo.

Se vocE<ecirc> achou isso complicado, esse exemplo rE<aacute>pido vai
ajudar:

 my @colors = qw(blue yellow black red);
 print Â@colors\nÂ;
 my $first_value = shift (@colors);
 print Â@colors\nÂ;
 print ÂFirst value is = $first_value\nÂ;

Executar o cE<oacute>digo gera como saE<iacute>da:

 4
 3
 First value is = blue

Diferentemente do cE<oacute>digo da funE<ccedil>E<atilde>o B<find_mp3>,
nesse exemplo foi passado um array como parE<acirc>metro para B<shift>:
por comodidade, se nenhum parE<acirc>metro E<eacute> informado para
essa funE<ccedil>E<atilde>o automaticamente ela adotarE<aacute> o
I<array> especial B<@ARGV>. E<Eacute> possE<iacute>vel simular listas e
pilhas utilizando as funE<ccedil>E<otilde>es B<pop>, B<push>, B<shift>
e B<unshift>. Outras funE<ccedil>E<otilde>es E<uacute>teis de
manipulaE<ccedil>E<atilde>o de I<array> sE<atilde>o B<map>, B<sort>,
B<grep>, B<reverse>, B<splice>, B<split>, B<join> e B<scalar>.

A segunda linha de B<find_mp3> nos apresenta duas coisas: a
funE<ccedil>E<atilde>o B<warn> e B<unless>. A funE<ccedil>E<atilde>o
B<warn> funciona como B<print>, mas envia uma mensagem (de aviso) para
B<STDERR> ao invE<eacute>s de B<STDOUT>. JE<aacute> B<unless> E<eacute>
a versE<atilde>o negada de B<if>: ao invE<eacute>s de fazer B<if ( !
$condicao )> o programador pode usar B<unless>. A diferenE<ccedil>a
E<eacute> meramente estE<eacute>tica, mas E<eacute> mais fE<aacute>cil
entender o programa desta forma (se vocE<ecirc> souber ler em
inglE<ecirc>s, claro).

A terceira linha declara um I<array> e usa uma variaE<ccedil>E<atilde>o
da funE<ccedil>E<atilde>o B<glob>. A funE<ccedil>E<atilde>o B<glob> (ou
sua variaE<ccedil>E<atilde>o usando "E<lt>" e "E<gt>") retorna uma
lista de nomes de arquivos que combinem com um parE<acirc>metro
fornecido. Nesse caso o B<glob> funciona de forma muito semelhante
E<agrave> digitar em um I<shell> um padrE<atilde>o de arquivo, como

 jackal@valhalla:~$ ls *.mp3

O que retornaria uma lista dos arquivos com nomes terminados em
E<147>.mp3E<148>.

A terceira linha tambE<eacute>m poderia ser escrita desta forma:

    my @list = glob($location*.mp3);

retornando o mesmo resultado.

FunE<ccedil>E<otilde>es em versE<otilde>es modernas do Perl (5.6 e
maiores) sE<atilde>o chamadas utilizando-se o nome da
funE<ccedil>E<atilde>o seguida de parE<ecirc>nteses, mesmo que
vocE<ecirc> nE<atilde>o passe nenhum parE<acirc>metro para a
funE<ccedil>E<atilde>o. Obviamente, parE<acirc>metros para a
funE<ccedil>E<atilde>o devem ser colocados dentro dos
parE<ecirc>nteses.

Basta agora fazer a chamada da funE<ccedil>E<atilde>o, como E<eacute>
mostrado abaixo:

 my $location;
 my @mp3_list;
 
 if (@ARGV) {
 
     $location = $ARGV[0];
     print "Will try to find files at $location\n";
 
 } else {
 
     $location = getcwd;
     print "Will try to find files at current directory ($location)\n";
 
 }
     @mp3_list = find_mp3($location);

Repare que declarei o I<array> B<@mp3_list> antes da
declaraE<ccedil>E<atilde>o B<if-then-else> ao invE<eacute>s de
fazE<ecirc>-lo dentro de cada chamada da funE<ccedil>E<atilde>o
B<find_mp3>. Devido ao escopo aonde foi declarada E<eacute>
possE<iacute>vel que B<@mp3_list> seja utilizE<aacute>vel por todo o
programa (se vocE<ecirc> fizer dentro de um dos blocos
perceberE<aacute> que a pragma B<strict> irE<aacute> gerar uma
exceE<ccedil>E<atilde>o).

O programa jE<aacute> estE<aacute> quase pronto agora: basta agora ler
a propriedade de cada arquivo encontrado e imprimir o resultado na tela
(STDOUT). Essa E<eacute> a parte mais complicada do programa, se o
leitor considerar que a primeira coisa E<eacute> entender como
recuperar essas informaE<ccedil>E<otilde>es de um arquivo mp3. Eu mesmo
nE<atilde>o tenho a menor idE<eacute>ia de como fazer isso.

Felizmente para mim e vocE<ecirc>, alguE<eacute>m jE<aacute> teve esse
trabalho e escreveu o cE<oacute>digo necessE<aacute>rio,
disponibilizando um mE<oacute>dulo no CPAN.

Como vocE<ecirc> verE<aacute>, usar o mE<oacute>dulo nE<atilde>o exige
mais do que a declarar sua importaE<ccedil>E<atilde>o e executar uma
funE<ccedil>E<atilde>o, que retornarE<aacute> o resultado de alguma
forma. Isso funciona bem na maioria dos casos, jE<aacute> que os
detalhes da implementaE<ccedil>E<atilde>o do cE<oacute>digo
estE<atilde>o escondidos do programador atrE<aacute>s de uma interface
definida. Ler a documentaE<ccedil>E<atilde>o online do mE<oacute>dulo
tambE<eacute>m ajuda bastante. O mE<oacute>dulo que vamos usar, no
entanto, nE<atilde>o estE<aacute> na distribuiE<ccedil>E<atilde>o
padrE<atilde>o do Perl: vocE<ecirc> deve instalar ele. A maneira mais
fE<aacute>cil, para o caso especE<iacute>fico do descritor.pl,
E<eacute> ir atE<eacute> o I<website> http://search.cpan.org e
pesquisar por B<MP3::Info>. Na pE<aacute>gina sobre o mE<oacute>dulo,
basta baixar o arquivo tar.gz e executar a sequE<ecirc>ncia de comandos
abaixo (como usuE<aacute>rio I<root>):

 # tar xzvf mp3-info.tar.gz
 # perl Makefile.pl
 # make
 # make test
 # make install

Existem diversas outras formas de instalar um mE<oacute>dulo Perl: os
mE<oacute>dulos mais famosos jE<aacute> ganharam pacotes para sua
distribuiE<ccedil>E<atilde>o Linux favorita, entE<atilde>o vocE<ecirc>
pode procurar no respectivo repositE<oacute>rio por tal pacote. A
maneira mais confiE<aacute>vel, no entanto, de usar as E<uacute>ltimas
versE<otilde>es dos mE<oacute>dulos disponE<iacute>veis E<eacute>
utilizar o mE<oacute>dulo CPAN (disponE<iacute>vel na
distribuiE<ccedil>E<atilde>o padrE<atilde>o do Perl):

 # perl -MCPAN -e shell

Isso habilita um I<shell> para o usuE<aacute>rio, aonde E<eacute>
permitido pesquisar e instalar mE<oacute>dulos diretamente do CPAN
desde que haja uma conexE<atilde>o disponE<iacute>vel com a Internet (o
mE<oacute>dulo CPAN tambE<eacute>m suporta I<proxies>). Essa pequena
maravilha permite que interdependE<ecirc>ncias entre os mE<oacute>dulos
sejam resolvidas automaticamente, tal qual o B<apt-get> do Debian GNU
Linux faz.

Com o mE<oacute>dulo B<MP3::Info> instalado, vamos modificar uma
E<uacute>ltima vez o programa. Para evitar repetir linhas, apenas a
parte modificada serE<aacute> mostrada, em destaque:

 use Cwd;
 use MP3::Info;
 
 # parte do cÃ³digo foi omitida aqui
 
 @mp3_list = find_mp3($location);
 
 die "Cannot work without a valid list. Sorry\n" unless (@mp3_list);
 
 foreach my $mp3_file (@mp3_list) {
 
     my $mp3_tags = get_mp3tag($mp3_file) or die "Cannot retrieve tags from $mp3_file: $!\n";
     my %mp3_tags = %{$mp3_tags};
 
     format STDOUT_TOP =
 Report about all mp3 files found.
 Total files found: @<<<<<<<<
                    scalar(@mp3_list)
 
 .
 
     format STDOUT =
 File @<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<
      $mp3_file
 
 ARTIST         | TITLE          | ALBUM        | GENRE        | TRACK
 ---------------+----------------+--------------+--------------+------
 @<<<<<<<<<<<<< | @<<<<<<<<<<<<< | @<<<<<<<<<<< | @<<<<<<<<<<< | @||||
 $mp3_tags{ARTIST}, $mp3_tags{TITLE}, $mp3_tags{ALBUM}, $mp3_tags{GENRE}, $mp3_tags{TRACKNUM}
 
 .
 
     write;
 
 }
 
 # Essa funÃ§Ã£o procura por arquivos mp3 no diretÃ³rio
 # passado como argumento e retorna uma lista dos
 # arquivos encontrados
 sub find_mp3 {

Apesar das poucas novas linhas, o cE<oacute>digo inserido executa uma
quantidade razoE<aacute>vel de operaE<ccedil>E<otilde>es. A primeira
linha inserida usa a funE<ccedil>E<atilde>o B<die>, que com esse nome
sugestivo, faz a execuE<ccedil>E<atilde>o do programa ser abortada caso
nE<atilde>o exista nenhum item na lista B<@mp3_list>, imprimindo a
mensagem entre aspas passada como parE<acirc>metro.

A instruE<ccedil>E<atilde>o B<foreach> funciona basicamente como uma
instruE<ccedil>E<atilde>o for, com a diferenE<ccedil>a que vocE<ecirc>
nE<atilde>o precisa informar como deverE<aacute> ser feita a
iteraE<ccedil>E<atilde>o: B<foreach> irE<aacute>, automaticamente,
obter o tamanho da lista informada (no caso, B<@mp3_list>) e fazer
iteraE<ccedil>E<otilde>es esse mesmo nE<uacute>mero de vezes. A sintaxe
do B<foreach> exige o uso de parE<ecirc>nteses para declarar a lista
desejada (que nE<atilde>o precisa ser necessariamente um array) e a
abertura e fechamento de um bloco, respectivamente usando E<147>{E<147>
e E<147>}E<148>. Dentro desse bloco entE<atilde>o sE<atilde>o
declaradas as instruE<ccedil>E<otilde>es que serE<atilde>o executadas a
cada iteraE<ccedil>E<atilde>o do B<foreach>.

Na linha seguinte, executamos a funE<ccedil>E<atilde>o B<get_mp3tag>,
atribuindo seu retorno E<agrave> variE<aacute>vel B<$mp3_tags> ou
entE<atilde>o abortar o programa com B<die> caso essa
funE<ccedil>E<atilde>o retorne um erro. B<get_mp3tag> nE<atilde>o
E<eacute> uma funE<ccedil>E<atilde>o padrE<atilde>o do Perl, mas ela
foi importada para seu programa no momento que a
declaraE<ccedil>E<atilde>o B<use MP3::Info> foi executada. Repare como
a palavra reservada or foi utilizada para criar uma sentenE<ccedil>a
condicional: se a funE<ccedil>E<atilde>o B<get_mp3tag> nE<atilde>o
retornar nada, as instruE<ccedil>E<otilde>es depois de B<or>
serE<atilde>o executadas, no caso a funE<ccedil>E<atilde>o B<die>.
Repare tambE<eacute>m que na mensagem de B<die> E<eacute> concatenada a
variE<aacute>vel especial B<$!> que armazena a mensagem de erro
informada pelo sistema operacional. Isso E<eacute> E<uacute>til, por
exemplo, quando vocE<ecirc> nE<atilde>o tem permissE<atilde>o de
leitura num arquivo que tenta ler.

A documentaE<ccedil>E<atilde>o I<online> do mE<oacute>dulo B<MP3::Info>
informa que a funE<ccedil>E<atilde>o B<get_mp3tag> retorna uma
referE<ecirc>ncia a um I<hash>. Lembra-se quando eu disse que
variE<aacute>veis escalares podem armazenar referE<ecirc>ncias? Pois
bem, esse E<eacute> um caso. No entanto, para fins didE<aacute>ticos,
nE<atilde>o vamos nos aprofundar em referE<ecirc>ncias: apenas confie
no fato de que a instruE<ccedil>E<atilde>o seguinte obtem os valores
apontados pela referE<ecirc>ncia armazenada em B<$mp3_tags> e copia
para um novo I<hash>.

Mas o que E<eacute> um I<hash>? O I<hash> E<eacute> o terceiro e
E<uacute>ltimo tipo de variE<aacute>vel existente em Perl: tal como um
I<array>, um I<hash> E<eacute> uma lista de escalares: a grande
diferenE<ccedil>a entre um e outro E<eacute> que o acesso aos itens de
um I<hash> nE<atilde>o E<eacute> feito atravE<eacute>s de um
E<iacute>ndice numE<eacute>rico, mas uma seqE<uuml>E<ecirc>ncia de
caracteres chamada de chave. I<Hashes> sE<atilde>o muito
prE<aacute>ticos quando o programador nE<atilde>o sabe a
posiE<ccedil>E<atilde>o exata (o E<iacute>ndice numE<eacute>rico) de um
escalar dentro de uma lista: basta informa seu nome que o I<hash>
encontrarE<aacute> sozinho o item com o mesmo nome. I<Hashes>
tambE<eacute>m sE<atilde>o muito E<uacute>teis para pesquisas
nE<atilde>o-lineares em uma lista, jE<aacute> que Perl utiliza um
algorE<iacute>tmo muito rE<aacute>pido para localizar essas chaves.

I<Hashes> sE<atilde>o declarados com o sE<iacute>mbolo de percentual
seguido do nome do I<hash>. A declaraE<ccedil>E<atilde>o de seus
elementos pode ser feita toda de uma vez ou inserida por vez, indicando
sempre o nome da chave e depois seus respectivo valor:

 my %estados = ( 'SP', 'SÃ£o Paulo','RJ', 'Rio de Janeiro', 'PA', 'ParanÃ¡');
 # ou ainda
 my %estados2 = ( SP => 'SÃ£o Paulo', RJ => 'Rio de Janeiro', PA => 'ParanÃ¡');
 # colocando mais um estado em %estados2
 %estados2{MT} = 'Mato Grosso';

Seus elementos sE<atilde>o acessados da mesma forma que um array, mas
usando chaves (E<147>{E<147> e E<147>}E<148>) ao invE<eacute>s de
colchetes.

 print ÂSP Ã© a sigla para $estados{SP}\nÂ;
 # apaga a entrada ÂParanÃ¡Â
 delete $estados2{PA}

E<Eacute> possE<iacute>vel fazer a iteraE<ccedil>E<atilde>o entre os
itens de um I<hash> com B<foreach> da mesma forma como E<eacute> feito
com um I<array> utilizando as funE<ccedil>E<otilde>es B<keys> (que
coincidentemente retorna uma lista com todas as chaves de um I<hash>
passado como parE<acirc>metro), B<values> (que mais coincidentemente
ainda retorna uma lista com todos os valores de um I<hash> passado como
parE<acirc>metro) e B<each> (que, por mais incrE<iacute>vel que
pareE<ccedil>a, retorna cada par (chave e valor) de um I<hash> passado
como parE<acirc>metro). Mas para o descritor.pl nE<atilde>o vamos
utilizar nenhuma desses funE<ccedil>E<otilde>es para iterar sobre o
hash: a funE<ccedil>E<atilde>o B<get_mp3tag> retorna mais I<tags> do
que precisamos. As tags que queremos sE<atilde>o ARTIST, TITLE, ALBUM,
GENRE e TRACKNUM, sendo que essas seqE<uuml>E<ecirc>ncias sE<atilde>o
as chaves do I<hash> B<%mp3_tags>.

Depois de acessar os dados desejados, basta gerar uma saE<iacute>da
sobre as informaE<ccedil>E<otilde>es obtidas. Apesar de ser
possE<iacute>vel fazer isso com um simples B<print>, isso nE<atilde>o
seria tE<atilde>o divertido: o resultado final fica muito melhor a
definiE<ccedil>E<atilde>o de um formato de impressE<atilde>o, tal como
um relatE<oacute>rio, usando as funE<ccedil>E<otilde>es B<format> e
B<write>.

B<format> espera um nome de formato para impressE<atilde>o como
argumento (nE<atilde>o use parE<ecirc>nteses para passar os
parE<acirc>metros): B<STDOUT_TOP> e B<STDOUT> sE<atilde>o os formatos
padrE<otilde>es para cabeE<ccedil>alho da saE<iacute>da padrE<atilde>o
e saE<iacute>da padrE<atilde>o, respectivamente; vocE<ecirc> pode
definir formatos alternativos, no entanto. O formato deve ser definido
apE<oacute>s uma quebra de linha: tudo o que vocE<ecirc> inserir ali,
incluindo espaE<ccedil>os, E<eacute> considerado pelo Perl ao imprimir.

Campos no relatE<oacute>rio sE<atilde>o definidos com
B<@E<lt>E<lt>E<lt>E<lt>> (valores alinhados E<agrave> esquerda),
B<@E<gt>E<gt>E<gt>E<gt>E<gt>> (valores alinhados E<agrave> direita) e
B<@||||||> (valores centralizados). Cada caracter E<147>E<lt>E<148>,
E<147>E<gt>E<148> ou E<147>|E<148>, incluindo @, serE<aacute>
substituE<iacute>do por cada caracter lido da expressE<atilde>o
imediatamente apE<oacute>s dessa declaraE<ccedil>E<atilde>o (quebra de
linha). Uma expressE<atilde>o pode ser uma simples variE<aacute>vel ou
a chamada de uma funE<ccedil>E<atilde>o, como por exemplo scalar que
forE<ccedil>a B<@mp3_list> a retornar o nE<uacute>mero de itens que
possui. Para terminar o formato, basta usar um ponto final sem nenhum
espaE<ccedil>o ou tabulaE<ccedil>E<atilde>o a esquerda do mesmo.

B<write> imprime no handle de arquivo (por padrE<atilde>o B<STDOUT>) o
formato padrE<atilde>o definido pela variE<aacute>vel especial B<$~>
(que por padrE<atilde>o usa B<STDOUT>).

Sem mais delongas, um teste final com o descriptor.pl mostraria algo
parecido com isto:

=over

=item * Exemplo de saE<iacute>da do programa:

saE<iacute>da.png

=back

NE<atilde>o preciso lembrar o leitor sobre as
implicaE<ccedil>E<otilde>es legais sobre utilizaE<ccedil>E<atilde>o de
mp3's. No entanto nE<atilde>o existe problema nenhum em
usE<aacute>-los, por exemplo, no rE<aacute>dio do seu carro ou mp3
I<player> caso vocE<ecirc> tenha os CD's originais.

=head2 ConclusE<atilde>o

Apresentar todos os recursos do Perl em um tutorial rE<aacute>pido como
este E<eacute>, no mE<iacute>nimo, complicado. NE<atilde>o E<eacute>
possE<iacute>vel detalhar todas as variaE<ccedil>E<otilde>es de uso das
funE<ccedil>E<otilde>es demonstradas aqui. No entanto, o tutorial lhe
fornece informaE<ccedil>E<otilde>es suficientes para criar programas
E<uacute>teis como descritor.pl. Perl possui amplo suporte E<agrave>
escrita em dispositivos (arquivos, I<named pipes> e I<sockets>) mas o
uso desses recursos demandariam tutoriais E<agrave> parte,
entE<atilde>o foram omitidos para manter a brevidade do tutorial.
Logicamente, vocE<ecirc> pode fazer uso de todos redirecionadores de
saE<iacute>da existentes no seu sistema operacional (desde que ele
suporte esse tipo de recurso).

O programa descriptor.pl mostra uma possE<iacute>vel
soluE<ccedil>E<atilde>o para o problema proposto, e as
variaE<ccedil>E<otilde>es possE<iacute>veis para atingir o mesmo
resultado sE<atilde>o muito grandes. Esses mesmo programa pode ser
reduzido em um punhado de linhas, o suficiente talvez para digitar o
cE<oacute>digo diretamente na linha de comando (basta verificar, por
exemplo, o cE<oacute>digo Perl equivalente do programa DeCSS(5) escrito
originalmente em C). Obviamente o programa nE<atilde>o seria nada
legE<iacute>vel.

Como exercE<iacute>cio, vocE<ecirc> poderia melhorar muito esse
programa: mE<oacute>dulos como B<Getopt::Std> e B<Getopt::Long>
permitiriam usar chaves para indicar parE<acirc>metros em linha de
comando; os diversos mE<oacute>dulos B<DBI> ofereceriam suporte
E<agrave> diversos bancos de dados para inserir dados sobre sua
coleE<ccedil>E<atilde>o de mp3's e B<IO::Socket> permitiria (com algum
trabalho extra) fazer o programa consultar um repositE<oacute>rio CDDB
na falta de informaE<ccedil>E<otilde>es existentes num dos arquivos
lidos. As possibilidades sE<atilde>o enormes: verifique o
repositE<oacute>rio do CPAN mais perto de vocE<ecirc> e se deslumbre
com um novo significado para reaproveitamento de cE<oacute>digo.

=head2 Bibliografia

DocumentaE<ccedil>E<atilde>o online da distribuiE<ccedil>E<atilde>o
padrE<atilde>o do Perl (em inglE<ecirc>s):

=over

=item * man perl

=item * perldoc perlintro

=item * perldoc perlform

=item * perldoc perlop

=back

EndereE<ccedil>os na Internet:

Site oficial do Perl:http://www.perl.org/

Site oficial dos Perl monks (grande repositE<oacute>rio de tutoriais,
sem contar o excelente fE<oacute>rum): http://www.perlmonks.org/

Grupos de programadores Perl do Brasil (oficialmente chamados de monges
do Perl): http://brasil.pm.org/

Projeto de traduE<ccedil>E<atilde>o da documentaE<ccedil>E<atilde>o
online do Perl para o portuguE<ecirc>s do Brasil:
http://perl.org.br/view/

InformaE<ccedil>E<otilde>es sobre CDDB (em inglE<ecirc>s):

=over

=item * http://musicbrainz.org/wd/AboutMusicBrainz

=item *
http://www.freedb.org/modules.php?name=Sections&sop=viewarticle&artid=26#1-2

=back

InformaE<ccedil>E<otilde>es sobre o DeCSS e sua versE<atilde>o em Perl:

=over

=item * http://en.wikipedia.org/wiki/DeCSS

=item *
http://www.wired.com/news/culture/0,1284,42259,00.html?tw=wn20010307

=back

=head2 Obras impressas

B<ProgramaE<ccedil>E<atilde>o Perl>, traduE<ccedil>E<atilde>o em
portuguE<ecirc>s da terceira ediE<ccedil>E<atilde>o em inglE<ecirc>s
Autores: Larry Wall, Tom Christiansen e Jon Orwant Editora: Campus
ISBN: 85-352-0727-9

B<Guia de Consulta RE<aacute>pida Perl> Autor: DE<eacute>cio Jr.
Editora: Novatec ISBN: 85-85184-80-9

=head2 Notas

Notes

B<1> : O nome do programa E<eacute> *s2p*

B<2> : VocE<ecirc> encontrarE<aacute> muitas referE<ecirc>ncias sobre
isso na Internet, mas abreviado em inglE<ecirc>s: TIMTOWTDI (I<There Is
More Than a Way To Do It>).

B<3> : _Common Gateway Interface_, um padrE<atilde>o para criar
aplicaE<ccedil>E<otilde>es I<web> dinE<acirc>micas que ainda E<eacute>
muito utilizado.

B<4> : Essa palavra tem suas origens no fato do caracter de sustenido
ser chamado de I<hash> e o caracter de exclamaE<ccedil>E<atilde>o ser
chamado de I<bang> formando a palavra I<hashbang>, que mais tarde foi
reduzida para I<shebang>.

B<5> : Programa para quebrar a criptografia utilizada em DVD's.

----

=head1 AUTOR

Alceu Junior

=cut

#Pod::HTML2Pod conversion notes:
# 51819 bytes of input
#Sun Jan 31 01:45:30 2010 mantovani
# No a_name switch not specified, so will not try to render <a name='...'>
# No a_href switch not specified, so will not try to render <a href='...'>
